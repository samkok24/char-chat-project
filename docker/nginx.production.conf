events {
    worker_connections 1024;
}

http {
    # 업스트림 서버 정의
    upstream frontend {
        server frontend:3000;
    }

    upstream backend {
        server backend:8000;
    }

    upstream chat {
        server chat-server:3001;
    }

    # 로그 설정
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    # 기본 설정
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 100M;

    # Gzip 압축
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss;

    # =========================
    # Maintenance mode bypass (관리자 우회)
    # =========================
    # 운영 안전 목적:
    # - 점검 모드(503)를 켜도, 관리자/운영자는 사이트에 들어가 실제 동작 테스트를 해야 한다.
    # - Cloudflare/프록시 환경에서는 $remote_addr가 실제 사용자 IP가 아닐 수 있으므로,
    #   가장 단순하고 확실한 "쿠키 기반 우회"를 제공한다.
    #
    # 사용 방법(점검 ON 상태에서):
    # - 우회 쿠키 발급:  https://YOUR_DOMAIN/__maintenance/bypass?token=chapter8-bypass-v1
    # - 이후 동일 브라우저에서 /dashboard 등 접근하면 점검을 우회하여 정상 접근 가능
    #
    # 보안 주의:
    # - 토큰은 외부에 노출되지 않게 관리하세요. 필요 시 더 긴 값으로 교체 권장.
    map $cookie_maintenance_bypass $maintenance_bypass_ok {
        default 0;
        "chapter8-bypass-v1" 1;
    }

    # Cloudflare SSL 사용 전제: Origin(Nginx)은 HTTP(80)만 오픈해도 됨
    # (Cloudflare SSL 모드가 Full/Strict이면 Origin cert를 따로 세팅해야 함)
    server {
        listen 80;
        server_name _;

        # =========================
        # Maintenance mode (점검 모드)
        # =========================
        # - enable:  docker exec -it chapter8_nginx sh -lc "touch /etc/nginx/maintenance_on && nginx -s reload"
        # - disable: docker exec -it chapter8_nginx sh -lc "rm -f /etc/nginx/maintenance_on && nginx -s reload"
        #
        # 예상 완료 시간/공지 문구는 아래 JSON 파일로 입력(빌드 없이 즉시 반영)
        # - set: docker exec -it chapter8_nginx sh -lc 'cat > /etc/nginx/maintenance_info.json <<EOF
        # {"until":"2025-12-24 03:00 KST","message":"더 안정적인 서비스를 위해 점검 중입니다."}
        # EOF'
        # - clear: docker exec -it chapter8_nginx sh -lc "rm -f /etc/nginx/maintenance_info.json"
        #
        # 구현 방식:
        # - SPA(React) 라우트로 보내면 브라우저 URL이 그대로라서, 클라이언트 라우터가 /dashboard로 리다이렉트해
        #   "점검 ON인데 화면이 안 바뀌는" 현상이 생길 수 있다.
        # - 따라서 Nginx에서 정적 maintenance.html을 직접 내려준다(브라우저 URL이 /여도 점검 화면이 보임).
        error_page 503 /maintenance.html;

        # 점검 안내 데이터(JSON) - MaintenancePage에서 fetch로 읽는다.
        # 파일이 없으면 404로 내려가고, 프론트는 기본 문구만 보여준다.
        location = /maintenance-info.json {
            default_type application/json;
            add_header Cache-Control "no-store";
            root /etc/nginx;
            try_files /maintenance_info.json =404;
        }

        # 점검 페이지(정적 HTML)는 점검 가드에서 제외해야 한다.
        location = /maintenance.html {
            default_type text/html;
            add_header Cache-Control "no-store" always;
            root /etc/nginx;
            try_files /maintenance.html =404;
        }

        # 점검 우회 쿠키 발급(관리자용)
        # - 204 응답으로 쿠키만 심는다. (페이지 로드 없이도 동작)
        # - 점검 페이지에서 테스트 전, 이 URL을 한 번 열고(또는 curl) 새로고침하면 된다.
        location = /__maintenance/bypass {
            add_header Cache-Control "no-store" always;
            if ($arg_token = "chapter8-bypass-v1") {
                add_header Set-Cookie "maintenance_bypass=chapter8-bypass-v1; Path=/; Max-Age=3600; HttpOnly; SameSite=Lax" always;
                return 204;
            }
            return 403;
        }

        # =========================
        # Service Worker (절대 캐시 금지)
        # =========================
        # sw.js를 1y immutable로 캐시하면,
        # - 구버전 SW가 계속 남아 네트워크/청크 로드가 망가질 수 있고
        # - 배포 후에도 사용자 브라우저가 새 버전을 못 받아 "증상이 그대로"가 된다.
        # 따라서 sw.js는 항상 no-store로 내려준다.
        location = /sw.js {
            add_header Cache-Control "no-store" always;
            add_header Pragma "no-cache" always;
            expires -1;
            proxy_pass http://frontend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # =========================
        # SEO (robots.txt / sitemap.xml)
        # =========================
        # - SPA라도 robots/sitemap은 구글 크롤러의 발견/갱신 속도를 올려준다.
        # - backend-api가 동적으로 생성하므로, 루트 경로를 백엔드로 프록시한다.
        location = /robots.txt {
            add_header Cache-Control "no-store" always;
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location = /sitemap.xml {
            add_header Cache-Control "no-store" always;
            proxy_pass http://backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # 프론트엔드 (React 앱)
        location / {
            # ✅ 점검 모드가 켜져 있으면 503 → error_page로 /maintenance 렌더링
            # (단, 관리자 우회 쿠키가 있으면 점검을 우회한다)
            set $maintenance_on 0;
            if (-f /etc/nginx/maintenance_on) { set $maintenance_on 1; }
            if ($maintenance_bypass_ok = 1) { set $maintenance_on 0; }
            if ($maintenance_on = 1) { return 503; }

            # ✅ SPA HTML 캐시 방지(운영 안정성)
            # - 일부 모바일(크롬/카카오 커스텀탭)에서 구버전 index.html/청크가 고착되면
            #   API base/서비스워커 정리 코드가 갱신되지 않아 "홈이 빈 깡통"처럼 보일 수 있다.
            # - JS/CSS 등 정적 리소스는 아래 정규식 location에서 immutable로 캐시한다(성능 유지).
            add_header Cache-Control "no-store" always;
            add_header Pragma "no-cache" always;
            expires -1;
            proxy_pass http://frontend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # WebSocket 지원
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        # API 요청
        location /api/ {
            proxy_pass http://backend/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # 타임아웃 설정
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }

        # 정적 파일 (업로드된 파일)
        # ✅ 중요: 아래의 정적 확장자 정규식 location(~*\.(jpg|png|...))보다 우선 적용되어야 한다.
        # - 그렇지 않으면 /static/*.jpg 가 프론트로 프록시되어 404가 발생한다.
        location ^~ /static/ {
            proxy_pass http://backend/static/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # 캐싱 설정
            expires 7d;
            add_header Cache-Control "public";
        }

        # Socket.IO 연결
        location /socket.io/ {
            proxy_pass http://chat;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # WebSocket 타임아웃
            proxy_read_timeout 86400;
        }

        # 정적 파일 캐싱
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            proxy_pass http://frontend;
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
}


