# 웹툰 지원 기능 추가 기획서

## 📋 개요

### 목적
- 현재 텍스트만 지원하는 회차 시스템을 확장하여 **이미지도 업로드 가능**하도록 개선
- 웹소설(텍스트)과 웹툰(이미지)을 **하나의 통합된 시스템**으로 지원
- 투자자 시연을 위한 핵심 차별화 기능 구현

### 핵심 개념
```
회차(StoryChapter) = 텍스트(content) + 이미지(image_url) [선택]

1. 텍스트만 있음 → 웹소설 회차 (기존 방식)
2. 이미지 + 텍스트 → 웹툰 회차 (신규)
   - 사용자에게는 이미지만 표시
   - AI는 텍스트를 프롬프팅 (숨김)
```

### 동작 방식
| 상황 | 뷰어 표시 | 원작챗 프롬프팅 |
|------|----------|----------------|
| 텍스트만 | 텍스트 | 텍스트 |
| 텍스트 + 이미지 | **이미지만** | 텍스트 (숨김) |

---

## 🎯 요구사항 정의

### 핵심 개념
> **회차별로 이미지와 텍스트 모두 업로드 가능**
> - 이미지가 있으면 → 사용자는 이미지만 봄 (웹툰)
> - 이미지가 없으면 → 사용자는 텍스트 봄 (웹소설)
> - AI는 항상 텍스트를 프롬프팅

### 1단계: 데이터 구조 확장 (P0)
- [ ] StoryChapter 모델에 `image_url` 필드 추가
- [ ] 텍스트는 항상 필수 (원작챗용)
- [ ] 이미지는 선택 (있으면 웹툰, 없으면 웹소설)

### 2단계: 회차 업로드 UI (P0)
- [ ] 회차 생성 폼에 이미지 업로드 추가
- [ ] 텍스트 입력란 유지 (이미지와 별개)
- [ ] "이미지가 있으면 사용자에게는 이미지만 표시됩니다" 안내 문구

### 3단계: 뷰어 로직 (P0)
- [ ] 회차에 `image_url`이 있으면 이미지만 표시 (텍스트 숨김)
- [ ] 회차에 `image_url`이 없으면 텍스트 표시 (기존 방식)
- [ ] 동일한 뷰어 컴포넌트로 처리

### 4단계: 원작챗 (P0)
- [ ] 기존 로직 그대로 사용 (텍스트 기반 context-pack)
- [ ] 이미지 유무와 관계없이 항상 텍스트 프롬프팅

### 5단계: UX 최적화 (P1)
- [ ] 회차 목록에 이미지 썸네일 표시
- [ ] 이미지 로딩 최적화
- [ ] 모바일 반응형

---

## 📐 데이터베이스 설계

### Story 모델
```python
# backend-api/app/models/story.py

class Story(Base):
    # 기존 필드들 그대로 사용
    # content_type 필드 불필요!
    # 회차별로 이미지 유무로 자동 판단
```

### StoryChapter 모델 확장
```python
# backend-api/app/models/story_chapter.py

class StoryChapter(Base):
    # 기존 필드들...
    
    id = Column(UUID(), primary_key=True, default=uuid.uuid4, index=True)
    story_id = Column(UUID(), ForeignKey("stories.id", ondelete="CASCADE"), nullable=False, index=True)
    no = Column(Integer, nullable=False)
    title = Column(String(200), nullable=True)
    content = Column(Text, nullable=False)  # 항상 필수! (원작챗 프롬프팅용)
    
    # 신규 필드 추가
    image_url = Column(String(500), nullable=True)  # 긴 세로 이미지 (선택)
    # NULL이면 텍스트만 표시 (웹소설)
    # 값이 있으면 이미지만 표시 (웹툰), 텍스트는 숨김
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    view_count = Column(Integer, default=0)
```

### 마이그레이션 스크립트
```sql
-- migrations/add_image_support.sql

-- StoryChapter 테이블에 이미지 컬럼 추가
ALTER TABLE story_chapters
ADD COLUMN image_url VARCHAR(500) NULL;

-- Story 테이블 변경 불필요!
-- content 컬럼 NOT NULL 유지 (텍스트는 항상 필수)

-- 코멘트
COMMENT ON COLUMN story_chapters.image_url IS '웹툰 이미지 URL. NULL이면 텍스트 표시, 값이 있으면 이미지만 표시';
```

---

## 🔧 백엔드 API 설계

### 1. 회차 생성 API (기존 API 그대로 사용)

```
POST /api/story-chapters/
Content-Type: application/json
```

#### 요청 Body
```json
{
  "story_id": "uuid",
  "no": 1,
  "title": "1화 - 시작",
  "content": "주인공은 평범한 고등학생이었다...",
  "image_url": null
}
```

**중요**: `content`는 항상 필수! 이미지가 있어도 텍스트 입력 필요 (원작챗용)

### 2. 이미지 업로드 API (기존 Media API 활용)

**기존 API 사용!** 새로 만들 필요 없음

```
POST /api/media/upload
Content-Type: multipart/form-data
```

#### 사용 방법
```javascript
// 1단계: 이미지 업로드
const formData = new FormData();
formData.append('files', imageFile);

const uploadRes = await api.media.upload(formData);
const imageUrl = uploadRes.data.items[0].url;

// 2단계: 회차에 image_url 업데이트
await api.stories.updateChapter(chapterId, {
  image_url: imageUrl
});
```

#### 기존 코드 (backend-api/app/api/media.py)
```python
@router.post("/upload", response_model=MediaAssetListResponse)
async def upload_images(
    files: List[UploadFile] = File(...),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
):
    storage = get_storage()
    created: List[MediaAsset] = []
    for f in files:
        if not f.content_type or not f.content_type.startswith("image/"):
            raise HTTPException(status_code=400, detail="이미지 파일만 업로드할 수 있습니다.")
        ext = os.path.splitext(f.filename or "")[1] or ".png"
        buf = f.file.read()
        url = storage.save_bytes(buf, content_type=f.content_type or "image/png", key_hint=f"upload{ext}")
        asset = MediaAsset(
            id=str(uuid.uuid4()),
            user_id=str(current_user.id),
            url=url,
            status="ready",
        )
        db.add(asset)
        created.append(asset)
    await db.commit()
    return MediaAssetListResponse(items=[MediaAssetResponse.model_validate(a) for a in created])
```

**변경 필요 없음!** 기존 media upload API 그대로 사용

### 3. 원작챗 Context Pack (변경 불필요!)

```python
# backend-api/app/services/origchat_service.py

# 기존 build_context_pack 함수를 그대로 사용!
# 이미지 유무와 관계없이 항상 텍스트(content)를 프롬프팅
```

**변경 사항 없음!** 기존 로직 그대로 사용

---

## 🎨 프론트엔드 UI 설계

### 뷰어 방식

**웹툰 모드 (이미지 있을 때)**
- ✅ 헤더/제목 표시 (회차 번호, 제목)
- ✅ 회차 정보 표시 (조회수 등)
- ✅ 이미지(원고) 정중앙에 표시
- ✅ 스크롤로 내리면서 보기
- ✅ 배경: 검은색
- ❌ Story 표지는 표시 안 함 (회차 원고만)

**웹소설 모드 (이미지 없을 때)**
- ✅ 헤더/제목 표시
- ✅ 텍스트 콘텐츠 표시
- ✅ 기존 웹소설 뷰어와 동일

### 1. 회차 뷰어 컴포넌트 (조건부 표시)

```jsx
// frontend/char-chat-frontend/src/components/ChapterViewer.jsx

import React from 'react';

const ChapterViewer = ({ chapter }) => {
  const hasImage = chapter.image_url;  // 이미지 유무 확인
  
  return (
    <div className="chapter-viewer">
      {/* 헤더는 항상 표시 (웹소설/웹툰 공통) */}
      <div className="chapter-header bg-gray-900 sticky top-0 z-10 px-4 py-4 border-b border-gray-800">
        <div className="max-w-4xl mx-auto">
          <h2 className="text-xl font-bold text-white mb-1">
            {chapter.no}화 - {chapter.title}
          </h2>
          <div className="text-gray-400 text-sm">
            조회수 {chapter.view_count || 0}
          </div>
        </div>
      </div>

      {/* 콘텐츠 영역 - 조건부 렌더링 */}
      {hasImage ? (
        // 이미지가 있으면 이미지 표시 (웹툰)
        <div className="webtoon-content bg-black min-h-screen flex flex-col items-center py-8">
          <img 
            src={chapter.image_url} 
            alt="웹툰 원고"
            className="w-full max-w-4xl h-auto"
            style={{ display: 'block' }}
          />
          {/* 텍스트는 숨김 - AI만 사용 */}
        </div>
      ) : (
        // 이미지가 없으면 텍스트 표시 (웹소설)
        <div className="novel-content max-w-4xl mx-auto px-4 py-8">
          <div className="prose prose-invert max-w-none">
            <div className="text-white text-lg leading-relaxed whitespace-pre-wrap">
              {chapter.content}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default ChapterViewer;
```

### 2. 회차 생성 페이지

```jsx
// frontend/char-chat-frontend/src/pages/ChapterEditorPage.jsx

import { useState } from 'react';
import { Button } from '../components/ui/button';
import { Textarea } from '../components/ui/textarea';
import { Upload } from 'lucide-react';

const ChapterEditorPage = () => {
  const [formData, setFormData] = useState({
    no: 1,
    title: '',
    content: ''
  });
  const [image, setImage] = useState(null);
  const [imagePreview, setImagePreview] = useState(null);
  
  const handleImageChange = (e) => {
    const file = e.target.files[0];
    if (file) {
      setImage(file);
      setImagePreview(URL.createObjectURL(file));
    }
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // 1단계: 회차 생성 (텍스트)
    const chapterRes = await api.stories.createChapter({
      ...formData,
      story_id: storyId
    });
    
    const chapterId = chapterRes.data.id;
    
    // 2단계: 이미지 업로드 (선택) - 기존 media API 활용
    if (image) {
      const formData = new FormData();
      formData.append('files', image);
      
      // 기존 media upload API 사용
      const uploadRes = await api.media.upload(formData);
      const imageUrl = uploadRes.data.items[0].url;
      
      // 회차에 image_url 업데이트
      await api.stories.updateChapter(chapterId, {
        image_url: imageUrl
      });
    }
    
    toast.success('회차가 생성되었습니다!');
    navigate(`/story/${storyId}`);
  };
  
  return (
    <div className="max-w-4xl mx-auto px-4 py-12">
      <h1 className="text-3xl font-bold text-white mb-8">새 회차 추가</h1>
      
      <form onSubmit={handleSubmit} className="space-y-6">
        <div>
          <label className="block text-white font-semibold mb-2">회차 번호</label>
          <input
            type="number"
            value={formData.no}
            onChange={(e) => setFormData({...formData, no: parseInt(e.target.value)})}
            className="w-full px-4 py-3 bg-gray-800 text-white rounded-lg"
            min="1"
            required
          />
        </div>
        
        <div>
          <label className="block text-white font-semibold mb-2">제목</label>
          <input
            type="text"
            value={formData.title}
            onChange={(e) => setFormData({...formData, title: e.target.value})}
            className="w-full px-4 py-3 bg-gray-800 text-white rounded-lg"
            placeholder="1화 - 시작"
          />
        </div>
        
        <div>
          <label className="block text-white font-semibold mb-2">
            내용 (필수 - 원작챗에서 사용됩니다)
          </label>
          <Textarea
            value={formData.content}
            onChange={(e) => setFormData({...formData, content: e.target.value})}
            className="w-full px-4 py-3 bg-gray-800 text-white rounded-lg h-64"
            placeholder="텍스트를 입력하세요. 이미지를 업로드하면 사용자에게는 이미지만 표시되고, 이 텍스트는 AI가 읽습니다."
            required
          />
          <p className="text-sm text-gray-400 mt-2">
            ℹ️ 텍스트는 항상 입력해야 합니다. 이미지가 있어도 AI는 텍스트를 읽어서 대화합니다.
          </p>
        </div>
        
        <div>
          <label className="block text-white font-semibold mb-2">
            이미지 (선택 - 웹툰용)
          </label>
          <div className="border-2 border-dashed border-gray-600 rounded-lg p-8 text-center">
            {imagePreview ? (
              <div>
                <img src={imagePreview} alt="미리보기" className="max-h-96 mx-auto mb-4" />
                <Button
                  type="button"
                  onClick={() => {
                    setImage(null);
                    setImagePreview(null);
                  }}
                  className="bg-red-600 hover:bg-red-700"
                >
                  이미지 제거
                </Button>
              </div>
            ) : (
              <label className="cursor-pointer">
                <Upload className="w-12 h-12 mx-auto text-gray-400 mb-4" />
                <p className="text-gray-400 mb-2">
                  클릭하여 이미지 업로드 (웹툰 원고)
                </p>
                <p className="text-sm text-gray-500">
                  이미지가 있으면 사용자에게는 이미지만 표시됩니다
                </p>
                <input
                  type="file"
                  accept="image/*"
                  onChange={handleImageChange}
                  className="hidden"
                />
              </label>
            )}
          </div>
        </div>
        
        <Button 
          type="submit"
          className="w-full bg-blue-600 hover:bg-blue-700 text-white py-4 rounded-lg font-semibold"
        >
          회차 생성
        </Button>
      </form>
    </div>
  );
};
```

### 3. 작품 상세 페이지 (회차 목록)

```jsx
// frontend/char-chat-frontend/src/pages/StoryDetailPage.jsx

const StoryDetailPage = () => {
  const { storyId } = useParams();
  const { data: story } = useQuery(['story', storyId], () => api.stories.getById(storyId));
  const { data: chapters } = useQuery(['chapters', storyId], () => api.stories.getChapters(storyId));
  
  return (
    <div>
      {/* 회차 목록 */}
      <div className="chapters-list space-y-2">
        {chapters?.map(ch => {
          const hasImage = !!ch.image_url;  // 이미지 유무 확인
          
          return (
            <div 
              key={ch.id} 
              className="chapter-item flex gap-4 p-4 bg-gray-800 rounded-lg hover:bg-gray-700 cursor-pointer"
              onClick={() => navigate(`/story/${storyId}/chapter/${ch.no}`)}
            >
              {hasImage && (
                // 이미지가 있으면 썸네일 표시
                <div className="flex-shrink-0 w-20 h-28 overflow-hidden rounded">
                  <img 
                    src={ch.image_url} 
                    alt={ch.title}
                    className="w-full h-full object-cover object-top"
                  />
                </div>
              )}
              <div className="flex-1">
                <h3 className="text-lg font-semibold text-white mb-1">
                  {ch.no}화 - {ch.title}
                  {hasImage ? (
                    <span className="ml-2 text-xs bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-600">
                      웹툰
                    </span>
                  ) : (
                    <span className="ml-2 text-xs bg-blue-600 text-white px-2 py-1 rounded hover:bg-blue-600">
                      웹소설
                    </span>
                  )}
                </h3>
                <p className="text-sm text-gray-400 line-clamp-2">
                  {ch.content?.substring(0, 100)}...
                </p>
                <div className="text-xs text-gray-500 mt-2">
                  조회수 {ch.view_count || 0}
                </div>
              </div>
            </div>
          );
        })}
      </div>
    </div>
  );
};
```

---

## 🚀 구현 단계별 체크리스트

### Phase 1: 데이터 구조 (30분)
- [ ] StoryChapter 모델에 `image_url` 필드 추가
- [ ] 마이그레이션 스크립트 작성 및 실행

### Phase 2: 백엔드 API (30분)
- [ ] StoryChapter 모델에 `image_url` 필드 추가 확인
- [ ] 기존 `/media/upload` API 활용 (새로 만들 필요 없음!)
- [ ] 회차 수정 API로 `image_url` 업데이트
- [ ] 기존 원작챗 API는 변경 불필요 확인

### Phase 3: 프론트엔드 UI (2-3시간)
- [ ] ChapterViewer 컴포넌트 수정 (조건부 렌더링)
- [ ] ChapterEditorPage 이미지 업로드 UI 추가
- [ ] StoryDetailPage 썸네일 + 웹툰 배지 표시 (파란색 bg-blue-600)

### Phase 4: 테스트 (1시간)
- [ ] 텍스트만 있는 회차 (웹소설) → 텍스트 표시
- [ ] 텍스트 + 이미지 회차 (웹툰) → 이미지만 표시
- [ ] 원작챗 시작 → 텍스트 기반 컨텍스트 확인
- [ ] 이미지 업로드 유효성 검사

### Phase 5: 최적화 (30분)
- [ ] 이미지 로딩 최적화
- [ ] 에러 핸들링
- [ ] 투자자 시연 준비

**총 예상 시간: 4-5시간 (반나절 이내)**

---

## 🔍 차별화 포인트 (투자자 시연용)

### 1. **유연한 콘텐츠 시스템**
- **강점**: 웹소설/웹툰 구분 없이 통합 관리
- **데모**: "하나의 작품에 텍스트 회차와 이미지 회차를 섞을 수 있습니다"
- **예시**: 1화(텍스트), 2화(이미지), 3화(텍스트) 혼합 가능
- **UI 차별화**: 파란색 배지(`bg-blue-600`)로 웹소설/웹툰 명확히 구분

### 2. **원작챗 정확도 100%**
- **장점**: 이미지가 있어도 작가가 작성한 텍스트로 AI 이해
- **비교**: Vision AI → 오류 가능, 비용 높음
- **우리**: 텍스트 기반 → 정확, 비용 0

### 3. **크리에이터 친화적**
- **간편함**: 텍스트 + 이미지 한 번에 업로드
- **자유도**: 이미지는 선택사항
- **명확한 가이드**: "이미지 있으면 독자는 이미지만 보고, AI는 텍스트 읽음"
- **일관된 브랜딩**: 웹소설/웹툰 모두 파란색 배지로 통일

### 4. **비용 효율적**
- **Vision AI 불필요** → 월 운영비 $0
- **기존 인프라 활용** → 추가 개발 최소화
- **빠른 구현** → 1일 내 완성 가능

---

## ⚠️ 리스크 및 대응 방안

### 리스크 1: 텍스트 품질
- **문제**: 이미지만 보는 사용자는 텍스트 품질을 모름
- **대응**: 
  - 텍스트 최소 길이 제한 (100자)
  - 가이드: "대사와 상황 설명을 포함하세요"
  - 원작챗 품질로 텍스트 품질 확인 가능

### 리스크 2: 혼동 가능성
- **문제**: 사용자가 "이미지와 텍스트가 다르면 어떻게 되나?"
- **대응**:
  - 명확한 UI 안내 문구
  - 회차 생성 시 툴팁 표시
  - FAQ 작성

### 리스크 3: 이미지 저장 공간
- **문제**: 이미지 저장 공간 증가
- **대응**:
  - 이미지 압축 (WebP, 80% 품질)
  - 크기 제한 (5MB)
  - CDN 활용

---

## ✅ 최종 체크 (투자자 시연 전)

### 기능 테스트
- [ ] 텍스트만 회차 생성 → 텍스트 표시 확인
- [ ] 텍스트 + 이미지 회차 생성 → 이미지만 표시 확인
- [ ] 원작챗 시작 → 이미지 회차에서도 텍스트 기반 대화 확인
- [ ] 회차 목록에서 썸네일 표시 확인

### 시연 시나리오
1. **웹소설 회차 업로드** (30초)
   - 텍스트만 입력 → 생성 → 텍스트 뷰어 확인
   - **파란색 "웹소설" 배지 표시**
   
2. **웹툰 회차 업로드** (1분)
   - 텍스트 입력 → 이미지 업로드 → 이미지만 표시 확인
   - **파란색 "웹툰" 배지 표시**
   - "독자는 이미지만 보지만, AI는 텍스트를 읽습니다"

3. **혼합 작품 시연** (30초)
   - 회차 목록에서 웹소설/웹툰이 섞여 있는 모습 보여주기
   - 썸네일 + 배지로 직관적 구분

4. **원작챗 시작** (2분)
   - 원작챗 버튼 클릭
   - 웹툰 회차 기반으로 대화
   - "이미지만 봤지만 AI는 텍스트로 정확하게 이해합니다"

---

**작성일**: 2025-11-05  
**작성자**: AI Assistant  
**문서 버전**: 3.2 (최종)  
**프로젝트**: CaveDuck - 통합 콘텐츠 시스템 (웹소설 + 웹툰)  
**예상 구현 시간**: 4-5시간 (반나절 이내)  
**핵심**: Story/웹소설/웹툰 구분 없음, 회차별 이미지 선택, 텍스트 항상 필수, **기존 media API 활용**, **파란색 배지 통일**

